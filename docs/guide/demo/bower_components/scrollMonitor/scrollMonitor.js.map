{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///scrollMonitor.js","webpack:///webpack/bootstrap 1c74ef17285e47193503","webpack:///./index.js","webpack:///./src/constants.js","webpack:///./src/container.js","webpack:///./src/watcher.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_require","isInBrowser","ScrollMonitorContainer","scrollMonitor","document","body","setStateFromDOM","listenToDOM","window","VISIBILITYCHANGE","ENTERVIEWPORT","FULLYENTERVIEWPORT","EXITVIEWPORT","PARTIALLYEXITVIEWPORT","LOCATIONCHANGE","STATECHANGE","eventTypes","isOnServer","defaultOffsets","top","bottom","_classCallCheck","instance","Constructor","TypeError","getViewportHeight","element","innerHeight","documentElement","clientHeight","getContentHeight","Math","max","scrollHeight","offsetHeight","scrollTop","pageYOffset","Watcher","item","parentWatcher","calculateViewport","self","viewportTop","viewportBottom","viewportHeight","documentHeight","previousDocumentHeight","calculateViewportI","watchers","length","recalculateLocation","updateAndTriggerWatchers","updateAndTriggerWatchersI","update","triggerCallbacks","DOMListener","prototype","apply","arguments","containerWatcher","create","recalculateLocations","addEventListener","attachEvent","destroy","removeEventListener","detachEvent","event","contentHeight","setState","newViewportTop","newViewportHeight","newContentHeight","needsRecalcuate","latestEvent","i","createCustomContainer","createContainer","querySelector","container","offsets","watcher","push","beget","ElementWatcher","watchItem","triggerCallbackArray","listeners","listenerToTriggerListI","listener","callback","isOne","splice","callbacks","j","locked","wasInViewport","wasFullyInViewport","wasAboveViewport","wasBelowViewport","isInViewport","isFullyInViewport","isAboveViewport","isBelowViewport","previousTop","previousBottom","nodeName","cachedDisplay","style","display","containerOffset","boundingRect","getBoundingClientRect","height","undefined","on","Error","join","off","one","recalculateSize","index","indexOf","lock","unlock","eventHandlerFactory","type"],"mappings":"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","file":"scrollMonitor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(1),\n\t    isInBrowser = _require.isInBrowser;\n\t\n\tvar ScrollMonitorContainer = __webpack_require__(2);\n\t\n\tvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\n\tscrollMonitor.setStateFromDOM(null);\n\tscrollMonitor.listenToDOM();\n\t\n\tif (isInBrowser) {\n\t\twindow.scrollMonitor = scrollMonitor;\n\t}\n\t\n\tmodule.exports = scrollMonitor;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.VISIBILITYCHANGE = 'visibilityChange';\n\texports.ENTERVIEWPORT = 'enterViewport';\n\texports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\n\texports.EXITVIEWPORT = 'exitViewport';\n\texports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\n\texports.LOCATIONCHANGE = 'locationChange';\n\texports.STATECHANGE = 'stateChange';\n\t\n\texports.eventTypes = [exports.VISIBILITYCHANGE, exports.ENTERVIEWPORT, exports.FULLYENTERVIEWPORT, exports.EXITVIEWPORT, exports.PARTIALLYEXITVIEWPORT, exports.LOCATIONCHANGE, exports.STATECHANGE];\n\t\n\texports.isOnServer = typeof window === 'undefined';\n\texports.isInBrowser = !exports.isOnServer;\n\t\n\texports.defaultOffsets = { top: 0, bottom: 0 };\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _require = __webpack_require__(1),\n\t    isOnServer = _require.isOnServer,\n\t    isInBrowser = _require.isInBrowser,\n\t    eventTypes = _require.eventTypes;\n\t\n\tvar Watcher = __webpack_require__(3);\n\t\n\tfunction getViewportHeight(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t\t} else {\n\t\t\treturn element.clientHeight;\n\t\t}\n\t}\n\t\n\tfunction getContentHeight(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tif (element === document.body) {\n\t\t\t// jQuery approach\n\t\t\t// whichever is greatest\n\t\t\treturn Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);\n\t\t} else {\n\t\t\treturn element.scrollHeight;\n\t\t}\n\t}\n\t\n\tfunction scrollTop(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.pageYOffset || document.documentElement && document.documentElement.scrollTop || document.body.scrollTop;\n\t\t} else {\n\t\t\treturn element.scrollTop;\n\t\t}\n\t}\n\t\n\tvar ScrollMonitorContainer = function () {\n\t\tfunction ScrollMonitorContainer(item, parentWatcher) {\n\t\t\t_classCallCheck(this, ScrollMonitorContainer);\n\t\n\t\t\tvar self = this;\n\t\n\t\t\tthis.item = item;\n\t\t\tthis.watchers = [];\n\t\t\tthis.viewportTop = null;\n\t\t\tthis.viewportBottom = null;\n\t\t\tthis.documentHeight = getContentHeight(item);\n\t\t\tthis.viewportHeight = getViewportHeight(item);\n\t\t\tthis.DOMListener = function () {\n\t\t\t\tScrollMonitorContainer.prototype.DOMListener.apply(self, arguments);\n\t\t\t};\n\t\t\tthis.eventTypes = eventTypes;\n\t\n\t\t\tif (parentWatcher) {\n\t\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t\t}\n\t\n\t\t\tvar previousDocumentHeight;\n\t\n\t\t\tvar calculateViewportI;\n\t\t\tfunction calculateViewport() {\n\t\t\t\tself.viewportTop = scrollTop(item);\n\t\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\t\twhile (calculateViewportI--) {\n\t\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar updateAndTriggerWatchersI;\n\t\t\tfunction updateAndTriggerWatchers() {\n\t\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t\t}\n\t\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.update = function () {\n\t\t\t\tcalculateViewport();\n\t\t\t\tupdateAndTriggerWatchers();\n\t\t\t};\n\t\t\tthis.recalculateLocations = function () {\n\t\t\t\tthis.documentHeight = 0;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}\n\t\n\t\tScrollMonitorContainer.prototype.listenToDOM = function listenToDOM() {\n\t\t\tif (isInBrowser) {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t\tthis.destroy = function () {\n\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.destroy = function destroy() {\n\t\t\t// noop, override for your own purposes.\n\t\t\t// in listenToDOM, for example.\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.DOMListener = function DOMListener(event) {\n\t\t\t//alert('got scroll');\n\t\t\tthis.setStateFromDOM(event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.setStateFromDOM = function setStateFromDOM(event) {\n\t\t\tvar viewportTop = scrollTop(this.item);\n\t\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\t\tvar contentHeight = getContentHeight(this.item);\n\t\n\t\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.setState = function setState(newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\t\tvar needsRecalcuate = newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight;\n\t\n\t\t\tthis.latestEvent = event;\n\t\t\tthis.viewportTop = newViewportTop;\n\t\t\tthis.viewportHeight = newViewportHeight;\n\t\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\t\tthis.contentHeight = newContentHeight;\n\t\n\t\t\tif (needsRecalcuate) {\n\t\t\t\tvar i = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.updateAndTriggerWatchers = function updateAndTriggerWatchers(event) {\n\t\t\tvar i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].update();\n\t\t\t}\n\t\n\t\t\ti = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t\t}\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.createCustomContainer = function createCustomContainer() {\n\t\t\treturn new ScrollMonitorContainer();\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.createContainer = function createContainer(item) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.querySelector(item);\n\t\t\t} else if (item && item.length > 0) {\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\t\tcontainer.setStateFromDOM();\n\t\t\tcontainer.listenToDOM();\n\t\t\treturn container;\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.create = function create(item, offsets) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.querySelector(item);\n\t\t\t} else if (item && item.length > 0) {\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\t\tvar watcher = new Watcher(this, item, offsets);\n\t\t\tthis.watchers.push(watcher);\n\t\t\treturn watcher;\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.beget = function beget(item, offsets) {\n\t\t\treturn this.create(item, offsets);\n\t\t};\n\t\n\t\treturn ScrollMonitorContainer;\n\t}();\n\t\n\tmodule.exports = ScrollMonitorContainer;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(1),\n\t    VISIBILITYCHANGE = _require.VISIBILITYCHANGE,\n\t    ENTERVIEWPORT = _require.ENTERVIEWPORT,\n\t    FULLYENTERVIEWPORT = _require.FULLYENTERVIEWPORT,\n\t    EXITVIEWPORT = _require.EXITVIEWPORT,\n\t    PARTIALLYEXITVIEWPORT = _require.PARTIALLYEXITVIEWPORT,\n\t    LOCATIONCHANGE = _require.LOCATIONCHANGE,\n\t    STATECHANGE = _require.STATECHANGE,\n\t    eventTypes = _require.eventTypes,\n\t    defaultOffsets = _require.defaultOffsets;\n\t\n\tfunction ElementWatcher(containerWatcher, watchItem, offsets) {\n\t\tvar self = this;\n\t\n\t\tthis.watchItem = watchItem;\n\t\tthis.container = containerWatcher;\n\t\n\t\tif (!offsets) {\n\t\t\tthis.offsets = defaultOffsets;\n\t\t} else if (offsets === +offsets) {\n\t\t\tthis.offsets = { top: offsets, bottom: offsets };\n\t\t} else {\n\t\t\tthis.offsets = {\n\t\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t\t};\n\t\t}\n\t\n\t\tthis.callbacks = {}; // {callback: function, isOne: true }\n\t\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]] = [];\n\t\t}\n\t\n\t\tthis.locked = false;\n\t\n\t\tvar wasInViewport;\n\t\tvar wasFullyInViewport;\n\t\tvar wasAboveViewport;\n\t\tvar wasBelowViewport;\n\t\n\t\tvar listenerToTriggerListI;\n\t\tvar listener;\n\t\tfunction triggerCallbackArray(listeners, event) {\n\t\t\tif (listeners.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenerToTriggerListI = listeners.length;\n\t\t\twhile (listenerToTriggerListI--) {\n\t\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\t\tlistener.callback.call(self, event, self);\n\t\t\t\tif (listener.isOne) {\n\t\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.triggerCallbacks = function triggerCallbacks(event) {\n\t\n\t\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[ENTERVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[FULLYENTERVIEWPORT], event);\n\t\t\t}\n\t\n\t\t\tif (this.isAboveViewport !== wasAboveViewport && this.isBelowViewport !== wasBelowViewport) {\n\t\n\t\t\t\ttriggerCallbackArray(this.callbacks[VISIBILITYCHANGE], event);\n\t\n\t\t\t\t// if you skip completely past this element\n\t\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[FULLYENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[PARTIALLYEXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[ENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[EXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[PARTIALLYEXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[EXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[VISIBILITYCHANGE], event);\n\t\t\t}\n\t\t\tswitch (true) {\n\t\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[STATECHANGE], event);\n\t\t\t}\n\t\n\t\t\twasInViewport = this.isInViewport;\n\t\t\twasFullyInViewport = this.isFullyInViewport;\n\t\t\twasAboveViewport = this.isAboveViewport;\n\t\t\twasBelowViewport = this.isBelowViewport;\n\t\t};\n\t\n\t\tthis.recalculateLocation = function () {\n\t\t\tif (this.locked) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar previousTop = this.top;\n\t\t\tvar previousBottom = this.bottom;\n\t\t\tif (this.watchItem.nodeName) {\n\t\t\t\t// a dom element\n\t\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t\t}\n\t\n\t\t\t\tvar containerOffset = 0;\n\t\t\t\tvar container = this.container;\n\t\t\t\twhile (container.containerWatcher) {\n\t\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\t\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t\t}\n\t\t\t} else if (this.watchItem === +this.watchItem) {\n\t\t\t\t// number\n\t\t\t\tif (this.watchItem > 0) {\n\t\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t\t} else {\n\t\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// an object with a top and bottom property\n\t\t\t\tthis.top = this.watchItem.top;\n\t\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t\t}\n\t\n\t\t\tthis.top -= this.offsets.top;\n\t\t\tthis.bottom += this.offsets.bottom;\n\t\t\tthis.height = this.bottom - this.top;\n\t\n\t\t\tif ((previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom)) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[LOCATIONCHANGE], null);\n\t\t\t}\n\t\t};\n\t\n\t\tthis.recalculateLocation();\n\t\tthis.update();\n\t\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\t}\n\t\n\tElementWatcher.prototype = {\n\t\ton: function on(event, callback, isOne) {\n\t\n\t\t\t// trigger the event if it applies to the element right now.\n\t\t\tswitch (true) {\n\t\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isInViewport && this.isAboveViewport:\n\t\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\t\tif (isOne) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tthis.callbacks[event].push({ callback: callback, isOne: isOne || false });\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to add a scroll monitor listener of type ' + event + '. Your options are: ' + eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\toff: function off(event, callback) {\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type ' + event + '. Your options are: ' + eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\tone: function one(event, callback) {\n\t\t\tthis.on(event, callback, true);\n\t\t},\n\t\trecalculateSize: function recalculateSize() {\n\t\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\t\tthis.bottom = this.top + this.height;\n\t\t},\n\t\tupdate: function update() {\n\t\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\t\n\t\t\tthis.isInViewport = this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop;\n\t\t\tthis.isFullyInViewport = this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom || this.isAboveViewport && this.isBelowViewport;\n\t\t},\n\t\tdestroy: function destroy() {\n\t\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\t    self = this;\n\t\t\tthis.container.watchers.splice(index, 1);\n\t\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t\t}\n\t\t},\n\t\t// prevent recalculating the element location\n\t\tlock: function lock() {\n\t\t\tthis.locked = true;\n\t\t},\n\t\tunlock: function unlock() {\n\t\t\tthis.locked = false;\n\t\t}\n\t};\n\t\n\tvar eventHandlerFactory = function eventHandlerFactory(type) {\n\t\treturn function (callback, isOne) {\n\t\t\tthis.on.call(this, type, callback, isOne);\n\t\t};\n\t};\n\t\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tvar type = eventTypes[i];\n\t\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n\t}\n\t\n\tmodule.exports = ElementWatcher;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// scrollMonitor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1c74ef17285e47193503","var { isInBrowser } = require('./src/constants');\n\nvar ScrollMonitorContainer = require('./src/container');\n\nvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\nscrollMonitor.setStateFromDOM(null);\nscrollMonitor.listenToDOM();\n\nif (isInBrowser) {\n\twindow.scrollMonitor = scrollMonitor;\n}\n\nmodule.exports = scrollMonitor;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","exports.VISIBILITYCHANGE = 'visibilityChange';\nexports.ENTERVIEWPORT = 'enterViewport';\nexports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\nexports.EXITVIEWPORT = 'exitViewport';\nexports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\nexports.LOCATIONCHANGE = 'locationChange';\nexports.STATECHANGE = 'stateChange';\n\nexports.eventTypes = [\n\texports.VISIBILITYCHANGE,\n\texports.ENTERVIEWPORT,\n\texports.FULLYENTERVIEWPORT,\n\texports.EXITVIEWPORT,\n\texports.PARTIALLYEXITVIEWPORT,\n\texports.LOCATIONCHANGE,\n\texports.STATECHANGE\n];\n\nexports.isOnServer = (typeof window === 'undefined');\nexports.isInBrowser = !exports.isOnServer;\n\nexports.defaultOffsets = {top: 0, bottom: 0};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","var { isOnServer, isInBrowser, eventTypes } = require('./constants');\nvar Watcher = require('./watcher');\n\nfunction getViewportHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t} else {\n\t\treturn element.clientHeight;\n\t}\n}\n\nfunction getContentHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\n\tif (element === document.body) {\n\t\t// jQuery approach\n\t\t// whichever is greatest\n\t\treturn Math.max(\n\t\t\tdocument.body.scrollHeight, document.documentElement.scrollHeight,\n\t\t\tdocument.body.offsetHeight, document.documentElement.offsetHeight,\n\t\t\tdocument.documentElement.clientHeight\n\t\t);\n\t} else {\n\t\treturn element.scrollHeight;\n\t}\n}\n\nfunction scrollTop (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.pageYOffset ||\n\t\t\t(document.documentElement && document.documentElement.scrollTop) ||\n\t\t\tdocument.body.scrollTop;\n\t} else {\n\t\treturn element.scrollTop;\n\t}\n}\n\n\nclass ScrollMonitorContainer {\n\tconstructor (item, parentWatcher) {\n\t\tvar self = this;\n\n\t\tthis.item = item;\n\t\tthis.watchers = [];\n\t\tthis.viewportTop = null;\n\t\tthis.viewportBottom = null;\n\t\tthis.documentHeight = getContentHeight(item);\n\t\tthis.viewportHeight = getViewportHeight(item);\n\t\tthis.DOMListener = function () {\n\t\t\tScrollMonitorContainer.prototype.DOMListener.apply(self, arguments);\n\t\t};\n\t\tthis.eventTypes = eventTypes;\n\n\t\tif (parentWatcher) {\n\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t}\n\n\t\tvar previousDocumentHeight;\n\n\t\tvar calculateViewportI;\n\t\tfunction calculateViewport() {\n\t\t\tself.viewportTop = scrollTop(item);\n\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\twhile( calculateViewportI-- ) {\n\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t}\n\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t}\n\t\t}\n\n\t\tvar updateAndTriggerWatchersI;\n\t\tfunction updateAndTriggerWatchers() {\n\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t}\n\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update = function() {\n\t\t\tcalculateViewport();\n\t\t\tupdateAndTriggerWatchers();\n\t\t};\n\t\tthis.recalculateLocations = function() {\n\t\t\tthis.documentHeight = 0;\n\t\t\tthis.update();\n\t\t};\n\n\t}\n\n\tlistenToDOM () {\n\t\tif (isInBrowser) {\n\t\t\tif (window.addEventListener) {\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t} else {\n\t\t\t\t// Old IE support\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t}\n\t\t\tthis.destroy = function () {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdestroy () {\n\t\t// noop, override for your own purposes.\n\t\t// in listenToDOM, for example.\n\t}\n\n\tDOMListener (event) {\n\t\t//alert('got scroll');\n\t\tthis.setStateFromDOM(event);\n\t}\n\n\tsetStateFromDOM (event) {\n\t\tvar viewportTop = scrollTop(this.item);\n\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\tvar contentHeight = getContentHeight(this.item);\n\n\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t}\n\n\tsetState (newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\tvar needsRecalcuate = (newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight);\n\n\t\tthis.latestEvent = event;\n\t\tthis.viewportTop = newViewportTop;\n\t\tthis.viewportHeight = newViewportHeight;\n\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\tthis.contentHeight = newContentHeight;\n\n\t\tif (needsRecalcuate) {\n\t\t\tlet i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t}\n\t\t}\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tupdateAndTriggerWatchers (event) {\n\t\tlet i = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].update();\n\t\t}\n\n\t\ti = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t}\n\t}\n\n\tcreateCustomContainer () {\n\t\treturn new ScrollMonitorContainer();\n\t}\n\n\tcreateContainer (item) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\tcontainer.setStateFromDOM();\n\t\tcontainer.listenToDOM();\n\t\treturn container;\n\t}\n\n\tcreate (item, offsets) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar watcher = new Watcher(this, item, offsets);\n\t\tthis.watchers.push(watcher);\n\t\treturn watcher;\n\t}\n\n\tbeget (item, offsets) {\n\t\treturn this.create(item, offsets);\n\t}\n}\n\nmodule.exports = ScrollMonitorContainer;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/container.js","var {\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE,\n\teventTypes,\n\tdefaultOffsets\n} = require('./constants');\n\nfunction ElementWatcher (containerWatcher, watchItem, offsets) {\n\tvar self = this;\n\n\tthis.watchItem = watchItem;\n\tthis.container = containerWatcher;\n\n\tif (!offsets) {\n\t\tthis.offsets = defaultOffsets;\n\t} else if (offsets === +offsets) {\n\t\tthis.offsets = {top: offsets, bottom: offsets};\n\t} else {\n\t\tthis.offsets = {\n\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t};\n\t}\n\n\tthis.callbacks = {}; // {callback: function, isOne: true }\n\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tself.callbacks[eventTypes[i]] = [];\n\t}\n\n\tthis.locked = false;\n\n\tvar wasInViewport;\n\tvar wasFullyInViewport;\n\tvar wasAboveViewport;\n\tvar wasBelowViewport;\n\n\tvar listenerToTriggerListI;\n\tvar listener;\n\tfunction triggerCallbackArray (listeners, event) {\n\t\tif (listeners.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlistenerToTriggerListI = listeners.length;\n\t\twhile (listenerToTriggerListI--) {\n\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\tlistener.callback.call(self, event, self);\n\t\t\tif (listener.isOne) {\n\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t}\n\t\t}\n\t}\n\tthis.triggerCallbacks = function triggerCallbacks (event) {\n\n\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t}\n\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t}\n\n\n\t\tif (this.isAboveViewport !== wasAboveViewport &&\n\t\t\tthis.isBelowViewport !== wasBelowViewport) {\n\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\n\t\t\t// if you skip completely past this element\n\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t\t}\n\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t}\n\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t}\n\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\t\t}\n\t\tswitch( true ) {\n\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\ttriggerCallbackArray( this.callbacks[STATECHANGE], event );\n\t\t}\n\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\n\t};\n\n\tthis.recalculateLocation = function () {\n\t\tif (this.locked) {\n\t\t\treturn;\n\t\t}\n\t\tvar previousTop = this.top;\n\t\tvar previousBottom = this.bottom;\n\t\tif (this.watchItem.nodeName) { // a dom element\n\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t}\n\n\t\t\tvar containerOffset = 0;\n\t\t\tvar container = this.container;\n\t\t\twhile (container.containerWatcher) {\n\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t}\n\n\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t}\n\n\t\t} else if (this.watchItem === +this.watchItem) { // number\n\t\t\tif (this.watchItem > 0) {\n\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t} else {\n\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t}\n\n\t\t} else { // an object with a top and bottom property\n\t\t\tthis.top = this.watchItem.top;\n\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t}\n\n\t\tthis.top -= this.offsets.top;\n\t\tthis.bottom += this.offsets.bottom;\n\t\tthis.height = this.bottom - this.top;\n\n\t\tif ( (previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom) ) {\n\t\t\ttriggerCallbackArray( this.callbacks[LOCATIONCHANGE], null );\n\t\t}\n\t};\n\n\tthis.recalculateLocation();\n\tthis.update();\n\n\twasInViewport = this.isInViewport;\n\twasFullyInViewport = this.isFullyInViewport;\n\twasAboveViewport = this.isAboveViewport;\n\twasBelowViewport = this.isBelowViewport;\n}\n\nElementWatcher.prototype = {\n\ton: function (event, callback, isOne) {\n\n\t\t// trigger the event if it applies to the element right now.\n\t\tswitch( true ) {\n\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isInViewport && this.isAboveViewport:\n\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\tif (isOne) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks[event]) {\n\t\t\tthis.callbacks[event].push({callback: callback, isOne: isOne||false});\n\t\t} else {\n\t\t\tthrow new Error('Tried to add a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\toff: function( event, callback ) {\n\t\tif (this.callbacks[event]) {\n\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\tone: function( event, callback ) {\n\t\tthis.on( event, callback, true);\n\t},\n\trecalculateSize: function() {\n\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\tthis.bottom = this.top + this.height;\n\t},\n\tupdate: function() {\n\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\n\t\tthis.isInViewport = (this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop);\n\t\tthis.isFullyInViewport = (this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom) || (this.isAboveViewport && this.isBelowViewport);\n\n\t},\n\tdestroy: function() {\n\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\tself  = this;\n\t\tthis.container.watchers.splice(index, 1);\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t}\n\t},\n\t// prevent recalculating the element location\n\tlock: function() {\n\t\tthis.locked = true;\n\t},\n\tunlock: function() {\n\t\tthis.locked = false;\n\t}\n};\n\nvar eventHandlerFactory = function (type) {\n\treturn function( callback, isOne ) {\n\t\tthis.on.call(this, type, callback, isOne);\n\t};\n};\n\nfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\tvar type =  eventTypes[i];\n\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n}\n\nmodule.exports = ElementWatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/watcher.js"],"sourceRoot":""}